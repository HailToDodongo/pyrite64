*This is not intended as a complete guide, just as a small set of documentation to aid developers who might be interested in N64 Homebrew after the rise in popularity of pyrite64.*

# Useful Tips
Pyrite64 includes example projects within its directories, you can find these within the pyrite64/n64/examples directory. The project 'jam25' is the game you will have seen on YouTube - this is the gamejam submission but tidied up to work with pyrite64 (the original repository won't work, as the build-engine was moved in to the project since then - see commit 09a5858).

> [!TIP]
> Depending on where you have placed pyrite64, you may get an error regarding 'spaces in the filepath' even if there are none. Moving the examples into the documents directory fixes this.

# Pyrite64 'stack' 

Developing for the N64 is a little unlike developing for other hardware that a modern programmer may be used to. Nintendo deliberately did not include things like memory allocation or management, and the graphics subsystem takes customisable microcode in order to interpret display lists generated by the CPU. For understanding pyrite64 on a deeper level, it's important to be aware of the stack it uses to manage this complexity:

- Libdragon [docs](https://libdragon.dev/ref/topics.html): This is a community made, N64-specific C++ SDK for N64 which abstracts much of the complexity of developing for the console.

- Tiny3D [github](https://github.com/HailToDodongo/tiny3d): This is the microcode which the graphics subsystem uses to render the game, it also provides an API for using the subsystem. 

It is highly recommended that you use the Libdragon documentation while using pyrite64, and are aware of Tiny3D. Original reference manuals for the N64 are available and worth reading, [ultra64](https://ultra64.ca/) has done a fantastic job archiving the original software and manuals behind the N64. The first sixty pages of the Programming Manual (aside from the SGI-workstation installation) is a good glimpse into how difficult this hardware is to develop for, and what precisely libaries like Libdragon and Tiny3D are providing.

# Pyrite64-specific API
*This section will assume that you are comfortable using the example projects to get a sense of how to use the UI. For example, creating new scripts and binding those to a model.*

> [!TIP]
> Scripts should be made using the pyrite64 UI, as that will set aside a namespace for you and link it properly within the project.

Creating a new script within pyrite64 will generate a file within the src\user directory of the project with the following contents:

```
#include "script/userScript.h"
#include "scene/sceneManager.h"

namespace P64::Script::C87396D7374CC14B
{
  P64_DATA(
    // Put your arguments here if needed, those will show up in the editor.
    //
    // Types that can be set in the editor:
    // - uint8_t, int8_t, uint16_t, int16_t, uint32_t, int32_t
    // - float
    // - AssetRef<sprite_t>
    // - ObjectRefwd
    float height = 0.0f;
  );

  // The following functions are called by the engine at different points in the object's lifecycle.
  // If you don't need a specific function you can remove it.

  void initDelete(Object& obj, Data *data, bool isDelete)
  {
    if(isDelete) {
      // do cleanup
      return;
    }
    // do initialization
  }

  void update(Object& obj, Data *data, float deltaTime)
  {

  }

  void draw(Object& obj, Data *data, float deltaTime)
  {
  }

  void onEvent(Object& obj, Data *data, const ObjectEvent &event)
  {
  }

  void onCollision(Object& obj, Data *data, const Coll::CollEvent& event)
  {
  }
}
```

This script contains the five object lifecycles defined within pyrite64, it also contains the Object obj - which is the asset that you have attached the script to. 

The lifecycles are as follows:
- **initDelete**: This is run when the engine needs to dispose of your object as it no longer exists in scene. This can be useful for tracking and restoring global state - for instance resetting power-ups between levels. Alternatively you may wish to trigger some special logic when a particular object is deleted.

- **update**: This is run continously and is similar to a 'main' function for the mesh. Generally Controls and position updates go here to move your object around.

- **draw**: This is run when drawing the mesh, it can be used to add a shadow underneath your character for instance - where you need a function to run based on rendering your character.

- **onEvent**: This runs when another object sets an event on this object, either through interaction or collision. The ObjectEvent includes senderId, type, and value which are all integers. A simple example exists in jam25 on the interaction between onCollision in Player.cpp and onEvent in Coin.cpp.

- **onCollision**: This runs when this object collides with another objects collision box. A collision event includes a pointer to this collision box (selfBCS) the other objects collision box (otherBCS) and both of the meshes (selfMesh and otherMesh). 

Objects are of particular importance as they are the 3D Model to which the code is attached. The Object header file for scenes is well commented and should be used as a reference for the data and functions available on an object. Currently this resides in: pyrite64/n64/engine/include/scene/object.h

Reviewing this file is highly recommended, due to the early version when this guide was written (0.4 at time of posting) any information written here is liable to be either partially or completely out-of-date. Misleading documentation is worse than no documentation.